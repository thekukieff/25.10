#include <iostream>
#include <vector>
//vector and array реализуют модель хранения: линейный массив
//vector - решение по умолчанию для любой коллекции данных в программе, использовать другие требует только когда есть особые требования к алгоритмам
// которые будут взаимодействовать с коллекцией
// 
// требования для работы{
//	для того чтобы создать объект вектора требуется указать полный тип в качестве типа для работы 
//	
//	для работы основных методов класса тип для работы должен содержать{
//		1) конструктор по умолчанию
//		2) конструктор копирования
//		3) присваивание копированием
//		4) деструктор 
//	} 
//	
// для работы методов заполнения требуется наличие конструктор с параметрами
// 
// 
// 
// 
// }
// 
// 
// 
// 
//
class Demo {
public:
	Demo() { std::cout << "Def Constructor\n"; }
	Demo(int val):a_(val){ std::cout << "Param Constructor\n"; }
	Demo(const Demo&other):a_(other.a_){ std::cout << "Copy Constructor\n"; }//конструктор копироания
	~Demo(){ std::cout << "Def Destructor\n"; }

private:
	int a_;

};

int main() {
	std::vector <int> arr;
	//std::vector <void> arr2;//вектор от неполного типа void
	//первая строчка пройдет компиляцию, а вторая нет
	//такая же ошибка от абстрактного класса
	std::vector<Demo> arr3(12);
	//при создании вектора в его конструктор можно передать число
	// это создаст вектор в котором бкдет такое число пустых элементов
	// данный конструктор будет работать только если есть конструктор по умолчанию у хранимого класса
	arr3.reserve(1000);
	//метод резервирует под использование память на столько элементов 
	//сколько указали но не создает их сразу
	//при прочих равных правильнее создать пустой вектор и зарезервировать память а не создавать вектор пуустышек конструктором
	// 
	arr3.resize(20);
	//изменяет размер хранимых элементов (их количество)
	// если новый размер больше то в конец массива добавляются пустышки 
	// если новый размер меньше текущего количества то все что не поместилис ьуничтожаются
	//
	arr3.shrink_to_fit();
	//не изменяет количество хранимых элементов но освобождает неиспользуемый кусок памяти

	// для обоих требуется дополнительно конструктор копирования и копирования
	//
	arr3.push_back(Demo(4));
	arr3.emplace_back(6);
	//bush_back для классов с конструктором от 2х папраметров и более 
	//не сможет вызваться если напрямую не указать конструктор
	//emplace всегда принимает набор аргументов конструктора и не вызывает конструкторов копиования
	// 
	//
	arr3.pop_back();//удаляет самый последний элемент массива вместительность не трогает а size уменьшается

	auto it = arr3.begin();//метод дает итератор на начало коллекции

	arr3.erase(it);//удаляет что то конкретное
	//они схраняют местоположение первого элемента коллекции
	//при необходимости можно сместить его положение с помощью операторов ++ -- + - += -= по правилам арифметики
	arr3.erase(it + 2);
	//мы удалили элемент на две ячейки отстаящий от начала
	//размещение элементов на нужной позиции
	//
	arr3.insert(it+2,Demo(8));//лучше не использовать может вызвать конструктор
	arr3.emplace(it + 2, 6);//предпочтительнее

	//insert and push_back применяются когда есть образец 
	//emplace and emplace_back применяются когда нужно содздать объект

	return 0;
}